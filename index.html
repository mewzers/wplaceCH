<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pixel Art Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #414141;
      color: #fff;
      font-family: Arial, sans-serif;
      height: 100%;
      overflow-x: hidden;
      touch-action: none; /* Important pour désactiver le scroll natif sur mobile lors du pinch/drag */
    }
    /* Le div flouté de fond */
    #blur-bg {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      backdrop-filter: blur(8px);
      background: rgba(65, 65, 65, 0.6);
      z-index: 900; /* derrière l'image zoomée (1000) */
      display: none; /* caché par défaut */
    }
    img {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
      width: 100%;
      max-width: 800px;
      height: auto;
      cursor: zoom-in;
      transition: none;
      position: relative;
      z-index: 1001; /* au-dessus du blur */
      user-select: none;
      touch-action: none; /* désactive le comportement tactile natif */
    }
    /* Styles utilisés uniquement en mode zoomé */
    img.zoomed {
      position: fixed;
      top: 50%;
      left: 50%;
      width: auto;
      max-width: none;
      height: auto;
      max-height: none;
      cursor: zoom-in;
      transform-origin: center center;
      transform: scale(3) translate(0, 0);
      transition: transform 0.1s ease-out;
      z-index: 1001;
      user-select: none;
      touch-action: none;
    }
    .link-container {
      position: absolute;
      text-align: left;
      margin-top: 10px;
      font-size: 16px;
      max-width: 800px;
      top: 720px;
      left: 8px;
      z-index: 1;
    }
    .message-container {
      position: absolute;
      margin-top: 10px;
      font-size: 16px;
      max-width: 270px;
      top: 310px;
      left: 8px;
      text-align: justify;
      z-index: 1;
    }
    a {
      color: #4da3ff;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    /* HUD texte */
    #hud-text {
      display: none;
      position: fixed;
      bottom: 30px;
      width: 100%;
      text-align: center;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 18px;
      text-shadow: 0 0 5px black;
      user-select: none;
      pointer-events: none;
      z-index: 1100;
    }
    /* Responsive pour petits écrans */
    @media (max-width: 600px) {
      .message-container {
        max-width: 140px;
        font-size: 14px;
        top: 150px;
      }
      .link-container {
        font-size: 14px;
        top: 360px;
      }
      #hud-text {
        font-size: 14px;
        bottom: 15px;
      }
    }
  </style>
</head>
<body>
  <div id="blur-bg"></div> <!-- div flouté en fond -->
  <img id="pixel-art" src="Nintendo project pixels.png" alt="Pixel Art" />
  <div id="hud-text"></div>
  <div class="message-container" id="thanks-message"></div>
  <div class="link-container" id="grief-link"></div>

  <script>
    // Traductions
    const userLang = navigator.language || navigator.userLanguage;
    const translations = {
      fr: {
        grief: "En cas de vandalisme :",
        thanks: "Merci d'avoir pris le temps de scanner le QR code ! Ce pixel art est un projet communautaire et j'apprécierais énormément toute aide pour le maintenir ou l'améliorer ❤️.",
        hudPause: "espace pour mettre pause",
        tooltipZoomOut: "clique droit pour dézoomer"
      },
      de: {
        grief: "Bei Vandalismus :",
        thanks: "Danke, dass Sie sich die Zeit genommen haben, den QR-Code zu scannen! Dieses Pixel-Art ist ein Gemeinschaftsprojekt und jede Hilfe, es zu erhalten oder zu verbessern, wird sehr geschätzt ❤️.",
        hudPause: "Leertaste zum Pausieren",
        tooltipZoomOut: "rechtsklick zum herauszoomen"
      },
      it: {
        grief: "In caso di vandalismo :",
        thanks: "Grazie per aver preso il tempo di scansionare il QR code! Questo pixel art è un progetto comunitario e apprezzerei moltissimo qualsiasi aiuto per mantenerlo o migliorarlo ❤️.",
        hudPause: "spazio per mettere in pausa",
        tooltipZoomOut: "clic destro per zoom indietro"
      },
      en: {
        grief: "In case of grief :",
        thanks: "Thank you for taking the time to scan the QR code! This pixel art is a community project, and I would greatly appreciate any help to maintain or improve it ❤️.",
        hudPause: "space to pause",
        tooltipZoomOut: "right click to zoom out"
      }
    };

    const langCode = userLang.substring(0, 2).toLowerCase();
    const messages = translations[langCode] || translations.en;

    document.getElementById("grief-link").innerHTML =
      `${messages.grief} <a href="https://www.reddit.com/r/WplaceLive/comments/1mew9yn/report_users/" target="_blank" rel="noopener noreferrer">https://www.reddit.com/r/WplaceLive/comments/1mew9yn/report_users/</a>`;

    document.getElementById("thanks-message").innerHTML = messages.thanks;

    // On place le texte HUD traduit
    const hudText = document.getElementById("hud-text");
    hudText.textContent = messages.hudPause;

    const img = document.getElementById("pixel-art");
    const blurBg = document.getElementById("blur-bg");

    let zoomLevel = 0;  // 0 = normal, 1 = zoom 1, 2 = zoom 2 (PC uniquement)
    let targetX = 50, targetY = 50;
    let currentX = 50, currentY = 50;
    let isPaused = false;

    // Variables zoom tactile
    let scale = 1;
    let lastScale = 1;
    let startTouches = [];
    let originX = 50; // % relatif pour transform-origin
    let originY = 50;
    let lastTranslateX = 0;
    let lastTranslateY = 0;
    let translateX = 0;
    let translateY = 0;

    // Gestion souris clic (PC)
    img.addEventListener("click", (e) => {
      if (e.button === 0 && !isTouchDevice()) { // Ignore clic tactile
        if (zoomLevel < 2) {
          zoomLevel++;
          if (zoomLevel === 1) {
            targetX = currentX = 50;
            targetY = currentY = 50;
            // Reset zoom tactile
            scale = 6;
            translateX = 0;
            translateY = 0;
            lastTranslateX = 0;
            lastTranslateY = 0;
            img.style.transformOrigin = `50% 50%`;
            img.style.transform = `scale(${scale}) translate(0, 0)`;
          }
          img.classList.add("zoomed");
          blurBg.style.display = "block";
          hudText.style.display = "block";
          img.style.cursor = "zoom-in";
          img.setAttribute("title", messages.tooltipZoomOut);
        } else if (zoomLevel === 2) {
          zoomLevel = 0;
          img.classList.remove("zoomed");
          img.style.transform = "";
          img.style.transformOrigin = "center center";
          img.style.cursor = "zoom-in";
          blurBg.style.display = "none";
          hudText.style.display = "none";
          img.removeAttribute("title");
          isPaused = false;
          hudText.textContent = messages.hudPause;
          // Reset zoom tactile aussi
          scale = 1;
          translateX = 0;
          translateY = 0;
          lastTranslateX = 0;
          lastTranslateY = 0;
        }
      }
    });

    // Clic droit = dézoom progressif (2 -> 1 -> 0)
    img.addEventListener("contextmenu", (e) => {
      if (!isTouchDevice()) {
        e.preventDefault();
        if (zoomLevel > 0) {
          zoomLevel--;
          if (zoomLevel === 0) {
            img.classList.remove("zoomed");
            img.style.transform = "";
            img.style.transformOrigin = "center center";
            img.style.cursor = "zoom-in";
            blurBg.style.display = "none";
            hudText.style.display = "none";
            img.removeAttribute("title");
            isPaused = false;
            hudText.textContent = messages.hudPause;
            // Reset zoom tactile aussi
            scale = 1;
            translateX = 0;
            translateY = 0;
            lastTranslateX = 0;
            lastTranslateY = 0;
          } else {
            img.classList.add("zoomed");
            blurBg.style.display = "block";
            hudText.style.display = "block";
            img.style.cursor = "zoom-out";
            img.setAttribute("title", messages.tooltipZoomOut);
            setTimeout(() => {
              if (zoomLevel > 0) {
                img.style.cursor = "zoom-in";
              }
            }, 100);
          }
        }
      }
    });

    // Déplacement souris quand zoom PC
    document.addEventListener("mousemove", (e) => {
      if (zoomLevel === 0 || isPaused || isTouchDevice()) return;
      targetX = (e.clientX / window.innerWidth) * 100;
      targetY = (e.clientY / window.innerHeight) * 100;
    });

    // Espace pause / reprise (PC)
    document.addEventListener("keydown", (e) => {
      if (zoomLevel === 0 || isTouchDevice()) return;
      if (e.code === "Space") {
        e.preventDefault();
        isPaused = !isPaused;
        hudText.textContent = isPaused
          ? (langCode === "fr"
              ? "déplacement figé (espace pour reprendre)"
              : translations[langCode]?.hudPause
              ? translations[langCode].hudPause + " (press space to resume)"
              : "paused (press space to resume)")
          : messages.hudPause;
      }
    });

    // Animation PC zoom
    function animate() {
      if (zoomLevel > 0 && !isTouchDevice()) {
        currentX += (targetX - currentX) * 0.05;
        currentY += (targetY - currentY) * 0.05;
        img.style.transformOrigin = `${currentX}% ${currentY}%`;
        const scalePC = zoomLevel === 1 ? 6 : 12;
        img.style.transform = `scale(${scalePC})`;
      }
      requestAnimationFrame(animate);
    }
    animate();

    // Détection simple de touch device
    function isTouchDevice() {
      return ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }

    // Helper pour distance 2 doigts
    function getDistance(touches) {
      const [touch1, touch2] = touches;
      const dx = touch2.clientX - touch1.clientX;
      const dy = touch2.clientY - touch1.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Helper midpoint 2 doigts
    function getMidpoint(touches) {
      const [touch1, touch2] = touches;
      return {
        x: (touch1.clientX + touch2.clientX) / 2,
        y: (touch1.clientY + touch2.clientY) / 2,
      };
    }

    // Touchstart pour zoom tactile
    img.addEventListener("touchstart", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        startTouches = [...e.touches];
        lastScale = scale;
        const midpoint = getMidpoint(e.touches);
        originX = (midpoint.x / window.innerWidth) * 100;
        originY = (midpoint.y / window.innerHeight) * 100;
        lastTranslateX = translateX;
        lastTranslateY = translateY;

        // Si on n'est pas en mode zoom tactile encore, activer zoomed et blur
        if (!img.classList.contains("zoomed")) {
          img.classList.add("zoomed");
          blurBg.style.display = "block";
          hudText.style.display = "block";
          img.style.cursor = "move";
          img.removeAttribute("title");
        }
      } else if (e.touches.length === 1 && scale > 1) {
        e.preventDefault();
        startTouches = [...e.touches];
        lastTranslateX = translateX;
        lastTranslateY = translateY;
      }
    });

    // Touchmove pour pinch + drag
    img.addEventListener("touchmove", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const currentDistance = getDistance(e.touches);
        const startDistance = getDistance(startTouches);
        const scaleChange = currentDistance / startDistance;
        scale = Math.min(Math.max(lastScale * scaleChange, 1), 12);

        img.style.transformOrigin = `${originX}% ${originY}%`;
        img.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
      } else if (e.touches.length === 1 && scale > 1) {
        e.preventDefault();
        const touch = e.touches[0];
        const startTouch = startTouches[0];
        const dx = touch.clientX - startTouch.clientX;
        const dy = touch.clientY - startTouch.clientY;

        translateX = lastTranslateX + dx / scale;
        translateY = lastTranslateY + dy / scale;

        img.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
      }
    });

    // Touchend pour reset si zoom < 1
    img.addEventListener("touchend", (e) => {
      if (e.touches.length === 0) {
        if (scale <= 1) {
          scale = 1;
          translateX = 0;
          translateY = 0;
          img.classList.remove("zoomed");
          blurBg.style.display = "none";
          hudText.style.display = "none";
          img.style.transform = "";
          img.style.cursor = "zoom-in";
          isPaused = false;
          hudText.textContent = messages.hudPause;
        }
        startTouches = [];
      }
    });
  </script>
</body>
</html>
